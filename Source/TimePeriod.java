//	TimePeriod.java - Represent a period of time.import java.util.Date;//	Most time values are manipulated as longs containing the number of milliseconds since the epoch defined//	by the Java API specification.  The shorthand for such values is "times in millis".//	//	To avoid endcase madness, Timelines defines specific time values (e.g. 10:22:32 or 3542434343 mS.)//	as denoting the (infinitely small) boundary BETWEEN time units.  Thus, 00:00:00 denotes the boundary//	between the last second of one day and the first second of the next day.abstract class TimePeriod {		public abstract long getPeriodStart();	public abstract long getPeriodEnd();	public abstract void setPeriodStart(long m);	public abstract void setPeriodEnd(long m);					//	Return the duration of this TimePeriod, in millis.	public long getDuration(){		return this.getPeriodEnd() - this.getPeriodStart();	}			//	Determine whether the provided time (in millis) is included in this period.	//	Note that the endpoints are inclusive.	public boolean includes(long time){		return (this.getPeriodStart() <= time) && (time <= this.getPeriodEnd());	}			//	Determine whether the provided time period is (entirely) included in this period.	public boolean includes(TimePeriod other){		return (this.getPeriodStart() <= other.getPeriodStart()) &&			(other.getPeriodEnd() <= this.getPeriodEnd());	}			//	Override of Object.equals().	//	See also equalsTimePeriod().	public boolean equals(Object other){		if (other == null || !(other instanceof TimePeriod))			return false;				TimePeriod otherPeriod = (TimePeriod)other;		return (this.getPeriodStart() == otherPeriod.getPeriodStart()) && 							(this.getPeriodEnd() == otherPeriod.getPeriodEnd());	}			//	This is a duplicate of equals(), useful since DataObject re-overrides equals().	//	??	This seeems like a warning flag that something should be changed.	public boolean equalsTimePeriod(Object other){		if (other == null || !(other instanceof TimePeriod))			return false;				TimePeriod otherPeriod = (TimePeriod)other;		return (this.getPeriodStart() == otherPeriod.getPeriodStart()) && 							(this.getPeriodEnd() == otherPeriod.getPeriodEnd());	}			//	Compute a TimePeriod which includes both this and the argument.	//	Note that the fast path is when this includes the argument.	public TimePeriod cover(TimePeriod other){		long thisStart = this.getPeriodStart();		long thisEnd = this.getPeriodEnd();		long otherStart = other.getPeriodStart();		long otherEnd = other.getPeriodEnd();				if (thisStart <= otherStart && thisEnd >= otherEnd)			return this;				long start = Math.min(thisStart, otherStart);		long end = Math.max(thisEnd, otherEnd);		return new ConcreteTimePeriod(start, end);	}			//	Override of Object.toString().	public String toString(){		StringBuffer buf = new StringBuffer();		buf.append("(TimePeriod from ");		buf.append((new Date(this.getPeriodStart())).toString());		buf.append(" to ");		buf.append((new Date(this.getPeriodEnd())).toString());		buf.append(")");		return buf.toString();	}}