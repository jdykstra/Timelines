//	TLState.java - Represent states in Timeline's data model.import java.io.*;import java.util.*;import java.util.List;class TLState extends DataObj implements Serializable {	//	Public constants.	//	Number of time parameters in a State.	public static final int PARAMETER_COUNT = 4;	protected static final int PREVIOUS_STREAM_VERSION = 7;	protected static final int PORTABLE_STREAM_VERSION = 8;		//	Define symbols for the four time parameters.	public static final int T0 = 0;	public static final int T1 = 1;	public static final int T2 = 2;	public static final int T3 = 3;	//	Instance fields.	protected TLEvent iStartedBy;			//	Starting event for this state	protected TLEvent iEndedBy;				//	Ending event for this state		//	Accessors.	public long getPeriodStart()			{ return iStartedBy.getPeriodStart();}	public long getPeriodEnd()				{ return iEndedBy.getPeriodEnd();}		public void setPeriodStart(long m)		{ throw new ImplementationException("Can't set TLState period");}	public void setPeriodEnd(long m)			{ throw new ImplementationException("Can't set TLState period");}	public TLEvent getStartingEvent()		{ return iStartedBy;}	public TLEvent getEndingEvent()			{ return iEndedBy;}	//	Constructor for building from a Macintosh input stream.  Along with the	//	stream, we're passed a list of the events in the file, and a list of the defined categories.	public TLState(MacInputStream is, List eventList, DefinedCategorySet definedCategoryList) throws IOException, FileFormatError {		Debug.assert(is.readShort() == 5);		//	Version number of TDataObj part		is.readShort();							//	2 unused bytes				//	Create a LabelInfo from the label and notes.		String label = is.readMacString();		String notes = is.readMacString();		iLabelInfo = new LabelInfo(label, notes, is.readMacBoolean());			//	Find the categories that this State is a part of.		iCategories = definedCategoryList.getSharedMemberSet(is);		//	Locate the starting and ending events.		Debug.assert(is.readShort() == 2);		//	Version number of State part		iStartedBy = (TLEvent)eventList.get(is.readShort() - 1); //	-1 to make zero-based		iEndedBy = (TLEvent)eventList.get(is.readShort() - 1);				is.readInt();							//	4 bytes unused	}			//	Constructor for building from a data input stream.  Along with the	//	stream, we're passed a list of the events in the file, and a list of the defined categories.	public TLState(DataInputStream is, TLEvent startEvt, TLEvent endEvt, DefinedCategorySet definedCategoryList) 														throws IOException, FileFormatError {		switch (is.readShort()){					case PREVIOUS_STREAM_VERSION:				//	Create a LabelInfo from the label and notes.				iLabelInfo = new LabelInfo(is.readUTF(), is.readUTF(), is.readBoolean());								//	This file version doesn't include timestamps.				iCreateTimestamp = DataObj.UNKNOWN_TIMESTAMP;				iModifyTimestamp = DataObj.UNKNOWN_TIMESTAMP;							//	Find the categories that this State is a part of.				iCategories = definedCategoryList.getSharedMemberSet(is);				//	Fill in the starting and ending events.				Debug.assert(startEvt != null && endEvt != null);				iStartedBy = startEvt;				iEndedBy = endEvt;				break;						case PORTABLE_STREAM_VERSION:				//	Create a LabelInfo from the label and notes.				iLabelInfo = new LabelInfo(is.readUTF(), is.readUTF(), is.readBoolean());								//	Read in the timestamps.				iCreateTimestamp = is.readLong();				iModifyTimestamp = is.readLong();							//	Find the categories that this State is a part of.				iCategories = definedCategoryList.getSharedMemberSet(is);				//	Fill in the starting and ending events.				Debug.assert(startEvt != null && endEvt != null);				iStartedBy = startEvt;				iEndedBy = endEvt;				break;						default:				Debug.assert(false, "unrecognized file component version");		}	}			//	Write the object to a data input stream.  Along with the	//	stream, we're passed two lists.  One is contains all defined categories, and we represent categories	//	in the output stream as their index in this list.  The second list contains all TLEvents in the document,	//	and we build it by adding the two TLEvents referenced by this TLState to the end of the list.	public void writeTo(DataOutputStream os) throws IOException {		os.writeShort(PORTABLE_STREAM_VERSION);				//	Write the label and notes.		os.writeUTF(iLabelInfo.getLabel());		os.writeUTF(iLabelInfo.getNotes());		os.writeBoolean(iLabelInfo.isLocked());			//	Write the timestamps.		os.writeLong(iCreateTimestamp);		os.writeLong(iModifyTimestamp);		//	Write out the categories that this State is a part of.		iCategories.writeTo(os);	}				//	Constructor for building from component objects.	public TLState(LabelInfo li, TLEvent startingEvent, TLEvent endingEvent, DefinedCategorySet.MemberSet categories){		super(li, categories);		iStartedBy = startingEvent;		iEndedBy = endingEvent;		checkSanity();	}			//	Constructor for creating from another TLState.	//	Pure Java style would use clone(), but I don't think that is a good design.	public TLState(TLState other){		this.setAllFrom(other);	}				//	Set value of this object from another TLState.	//	Note that, although the TLState stays the same, its constituent parts change.  	public void setAllFrom(TLState other){		super.setAllFrom(other);		iStartedBy = new TLEvent(other.iStartedBy);		iEndedBy =new TLEvent(other.iEndedBy);		checkSanity();	}	//	Make sure that the time values in this object make sense.	protected void checkSanity(){		if (Debug.sCurLevel >= 0){			Debug.assert(iStartedBy != null);			Debug.assert(iEndedBy != null);			Debug.assert(iEndedBy.getPeriodStart() >= iStartedBy.getPeriodStart());			Debug.assert(iEndedBy.getPeriodEnd() >= iStartedBy.getPeriodEnd());		}	}			//	Get the time parameter specified using a constant defined in this class (above).	public long getTimeParameter(int index){		switch (index){			case T0:				return iStartedBy.getPeriodStart();			case T1:				return iStartedBy.getPeriodEnd();			case T2:				return iEndedBy.getPeriodStart();			case T3:				return iEndedBy.getPeriodEnd();			default:				throw new ImplementationException("Illegal index");		}	}	//	Set the time parameter specified using a constant defined in this class (above).	public void setTimeParameter(int index, long value){		switch (index){			case T0:				 iStartedBy.setPeriodStart(value);   				 break;				 			case T1:				iStartedBy.setPeriodEnd(value);				 break;				 			case T2:				iEndedBy.setPeriodStart(value);				 break;				 			case T3:				iEndedBy.setPeriodEnd(value);				 break;				 			default:				throw new ImplementationException("Illegal index");		}	}	//	Overrides of standard methods.	public String toString(){		return "TLState \"" + iLabelInfo.getLabel() + "\"";	}	}