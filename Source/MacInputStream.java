//	MacInputStream.java - A InputStream that knows data formats used on the Macintosh.import java.io.*;import java.util.Date;import java.util.Calendar;import java.util.GregorianCalendar;//	The widths in bytes of types commonly used in the Macintosh Timelines code://	//		Boolean	1//		short		2//		int		4//		long		4class MacInputStream extends DataInputStream {	//	Public constants.	//	Map the integer values used by Mac file format to represent time units into	//	the values defined in interface TimeUnit.	protected static final int[] TIME_UNIT_TRANSLATOR = {			TimeUnit.YEAR, TimeUnit.MONTH, TimeUnit.WEEK, TimeUnit.DAY, 			TimeUnit.HOUR, TimeUnit.MINUTE, TimeUnit.SECOND, 		};			//	Constants for the time system used by the Macintosh implementation.	static final protected int MILLIS_IN_A_TOCK = 1000;		//	Each "tock" was one second.	static protected long MAC_EPOCH_MILLIS;		//	Starting point of Macintosh time system			//	Instance variables.	protected CustomGregorianCalendar iTempCalendar;		//	Calendar object for temporary use			static {		GregorianCalendar calendar = new GregorianCalendar();		calendar.clear();					//	probably not necessary, but doesn't hurt.		calendar.set(1903, 11, 31, 24, 0, 0);	//	Mac time started midnight, January 1, 1904		MAC_EPOCH_MILLIS = calendar.getTime().getTime();	}			//	Constructor.	public MacInputStream(InputStream is){		super(is);		//	Allocate a GregorianCalendar object for temporary use.		iTempCalendar = new CustomGregorianCalendar();	}			//	Read four bytes in Mac byte order, and return in a (signed) Java int.	public final int readMacInt() throws IOException {		return (int)this.readUnsignedMacInt();	}			//	Read four bytes as an unsigned quantity in Mac byte order, and return it in a Java long.	public final long readUnsignedMacInt() throws IOException {		InputStream in = this.in;		long ch1 = in.read();		long ch2 = in.read();		long ch3 = in.read();		long ch4 = in.read();		if ((ch1 | ch2 | ch3 | ch4) < 0)			throw new EOFException();		return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));	}			//	Read four bytes, with each pair of bytes swapped.  	//	??	I don't understand why this is necessary,	//	??	but the Mac format for CCategoryList seems to be in this form.	public final long readSwappedUnsignedMacInt() throws IOException {		InputStream in = this.in;		long ch1 = in.read();		long ch2 = in.read();		long ch3 = in.read();		long ch4 = in.read();		if ((ch1 | ch2 | ch3 | ch4) < 0)			throw new EOFException();		return ((ch1 << 24) + (ch4 << 16) + (ch2 << 8) + (ch3 << 0));	}	//	Read a CMoment object, and convert to Java time representation (millis).	public long readMacMoment() throws IOException {		Debug.assert(this.readShort() == 1);		//	Verify version		long milliValue =  this.readUnsignedMacInt() * MILLIS_IN_A_TOCK + MAC_EPOCH_MILLIS;				//	The Mac didn't keep track of daylight savings time.  Unfortunately, this		//	causes the many periods which were supposed to end at 23:59:59 to instead		//	spill into the next day.  Correct these values so they stay in the correct		//	day.		iTempCalendar.setTimeInMillis(milliValue);		long offset = iTempCalendar.get(Calendar.DST_OFFSET);		if (offset != 0){			milliValue -= offset;		}				return milliValue;	}			//	Read a Boolean value, and convert to Java boolean type.	public boolean readMacBoolean() throws IOException {		return this.readByte() != 0;	}			//	Read a CTLHeapString value, and convert to Java String type.	public String readMacString() throws IOException {		int size = this.readShort();				//	If the original string was null, return an empty String.		if (size == 0){			return "";		}		byte[] bytes = new byte[size - 1];		this.readFully(bytes);		this.readByte();			//	Discard null at end		return new String(bytes);	}}